{"contents":"var process = __fusereq(59);\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function (f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(\" \");\n  }\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function (x) {\n    if (x === \"%%\") return \"%\";\n    if (i >= len) return x;\n    switch (x) {\n      case \"%s\":\n        return String(args[i++]);\n      case \"%d\":\n        return Number(args[i++]);\n      case \"%j\":\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return \"[Circular]\";\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += \" \" + x;\n    } else {\n      str += \" \" + inspect(x);\n    }\n  }\n  return str;\n};\nexports.deprecate = function (fn, msg) {\n  if (isUndefined(window.process)) {\n    return function () {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n  return deprecated;\n};\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function (set) {\n  if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || \"\";\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp(\"\\\\b\" + set + \"\\\\b\", \"i\").test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function () {\n        var msg = exports.format.apply(exports, arguments);\n        console.error(\"%s %d: %s\", set, pid, msg);\n      };\n    } else {\n      debugs[set] = function () {};\n    }\n  }\n  return debugs[set];\n};\nfunction inspect(obj, opts) {\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    ctx.showHidden = opts;\n  } else if (opts) {\n    exports._extend(ctx, opts);\n  }\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\ninspect.colors = {\n  bold: [1, 22],\n  italic: [3, 23],\n  underline: [4, 24],\n  inverse: [7, 27],\n  white: [37, 39],\n  grey: [90, 39],\n  black: [30, 39],\n  blue: [34, 39],\n  cyan: [36, 39],\n  green: [32, 39],\n  magenta: [35, 39],\n  red: [31, 39],\n  yellow: [33, 39]\n};\ninspect.styles = {\n  special: \"cyan\",\n  number: \"yellow\",\n  boolean: \"yellow\",\n  undefined: \"grey\",\n  null: \"bold\",\n  string: \"green\",\n  date: \"magenta\",\n  regexp: \"red\"\n};\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n  if (style) {\n    return \"\\u001b[\" + inspect.colors[style][0] + \"m\" + str + \"\\u001b[\" + inspect.colors[style][1] + \"m\";\n  } else {\n    return str;\n  }\n}\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\nfunction arrayToHash(array) {\n  var hash = {};\n  array.forEach(function (val, idx) {\n    hash[val] = true;\n  });\n  return hash;\n}\nfunction formatValue(ctx, value, recurseTimes) {\n  if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n  if (isError(value) && (keys.indexOf(\"message\") >= 0 || keys.indexOf(\"description\") >= 0)) {\n    return formatError(value);\n  }\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? \": \" + value.name : \"\";\n      return ctx.stylize(\"[Function\" + name + \"]\", \"special\");\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\");\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), \"date\");\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n  var base = \"\", array = false, braces = [\"{\", \"}\"];\n  if (isArray(value)) {\n    array = true;\n    braces = [\"[\", \"]\"];\n  }\n  if (isFunction(value)) {\n    var n = value.name ? \": \" + value.name : \"\";\n    base = \" [Function\" + n + \"]\";\n  }\n  if (isRegExp(value)) {\n    base = \" \" + RegExp.prototype.toString.call(value);\n  }\n  if (isDate(value)) {\n    base = \" \" + Date.prototype.toUTCString.call(value);\n  }\n  if (isError(value)) {\n    base = \" \" + formatError(value);\n  }\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\");\n    } else {\n      return ctx.stylize(\"[Object]\", \"special\");\n    }\n  }\n  ctx.seen.push(value);\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function (key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n  ctx.seen.pop();\n  return reduceToSingleString(output, base, braces);\n}\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value)) return ctx.stylize(\"undefined\", \"undefined\");\n  if (isString(value)) {\n    var simple = \"'\" + JSON.stringify(value).replace(/^\"|\"$/g, \"\").replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + \"'\";\n    return ctx.stylize(simple, \"string\");\n  }\n  if (isNumber(value)) return ctx.stylize(\"\" + value, \"number\");\n  if (isBoolean(value)) return ctx.stylize(\"\" + value, \"boolean\");\n  if (isNull(value)) return ctx.stylize(\"null\", \"null\");\n}\nfunction formatError(value) {\n  return \"[\" + Error.prototype.toString.call(value) + \"]\";\n}\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));\n    } else {\n      output.push(\"\");\n    }\n  }\n  keys.forEach(function (key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));\n    }\n  });\n  return output;\n}\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || ({\n    value: value[key]\n  });\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize(\"[Getter/Setter]\", \"special\");\n    } else {\n      str = ctx.stylize(\"[Getter]\", \"special\");\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize(\"[Setter]\", \"special\");\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = \"[\" + key + \"]\";\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf(\"\\n\") > -1) {\n        if (array) {\n          str = str.split(\"\\n\").map(function (line) {\n            return \"  \" + line;\n          }).join(\"\\n\").substr(2);\n        } else {\n          str = \"\\n\" + str.split(\"\\n\").map(function (line) {\n            return \"   \" + line;\n          }).join(\"\\n\");\n        }\n      }\n    } else {\n      str = ctx.stylize(\"[Circular]\", \"special\");\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify(\"\" + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, \"name\");\n    } else {\n      name = name.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, \"string\");\n    }\n  }\n  return name + \": \" + str;\n}\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function (prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf(\"\\n\") >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, \"\").length + 1;\n  }, 0);\n  if (length > 60) {\n    return braces[0] + (base === \"\" ? \"\" : base + \"\\n \") + \" \" + output.join(\",\\n  \") + \" \" + braces[1];\n  }\n  return braces[0] + base + \" \" + output.join(\", \") + \" \" + braces[1];\n}\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\nfunction isBoolean(arg) {\n  return typeof arg === \"boolean\";\n}\nexports.isBoolean = isBoolean;\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\nfunction isNumber(arg) {\n  return typeof arg === \"number\";\n}\nexports.isNumber = isNumber;\nfunction isString(arg) {\n  return typeof arg === \"string\";\n}\nexports.isString = isString;\nfunction isSymbol(arg) {\n  return typeof arg === \"symbol\";\n}\nexports.isSymbol = isSymbol;\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === \"[object RegExp]\";\n}\nexports.isRegExp = isRegExp;\nfunction isObject(arg) {\n  return typeof arg === \"object\" && arg !== null;\n}\nexports.isObject = isObject;\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === \"[object Date]\";\n}\nexports.isDate = isDate;\nfunction isError(e) {\n  return isObject(e) && (objectToString(e) === \"[object Error]\" || e instanceof Error);\n}\nexports.isError = isError;\nfunction isFunction(arg) {\n  return typeof arg === \"function\";\n}\nexports.isFunction = isFunction;\nfunction isPrimitive(arg) {\n  return arg === null || typeof arg === \"boolean\" || typeof arg === \"number\" || typeof arg === \"string\" || typeof arg === \"symbol\" || typeof arg === \"undefined\";\n}\nexports.isPrimitive = isPrimitive;\nexports.isBuffer = __fusereq(97);\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\nfunction pad(n) {\n  return n < 10 ? \"0\" + n.toString(10) : n.toString(10);\n}\nvar months = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(\":\");\n  return [d.getDate(), months[d.getMonth()], time].join(\" \");\n}\nexports.log = function () {\n  console.log(\"%s - %s\", timestamp(), exports.format.apply(exports, arguments));\n};\nif (typeof Object.create === \"function\") {\n  exports.inherits = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  exports.inherits = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  };\n}\nexports._extend = function (origin, add) {\n  if (!add || !isObject(add)) return origin;\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n"}