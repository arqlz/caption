{"contents":"'use strict';\nmodule.exports = contentDisposition;\nmodule.exports.parse = parse;\nvar basename = __fusereq(29).basename;\nvar Buffer = __fusereq(39).Buffer;\nvar ENCODE_URL_ATTR_CHAR_REGEXP = /[\\x00-\\x20\"'()*,/:;<=>?@[\\\\\\]{}\\x7f]/g;\nvar HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;\nvar HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;\nvar NON_LATIN1_REGEXP = /[^\\x20-\\x7e\\xa0-\\xff]/g;\nvar QESC_REGEXP = /\\\\([\\u0000-\\u007f])/g;\nvar QUOTE_REGEXP = /([\\\\\"])/g;\nvar PARAM_REGEXP = /;[\\x09\\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\\x09\\x20]*=[\\x09\\x20]*(\"(?:[\\x20!\\x23-\\x5b\\x5d-\\x7e\\x80-\\xff]|\\\\[\\x20-\\x7e])*\"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\\x09\\x20]*/g;\nvar TEXT_REGEXP = /^[\\x20-\\x7e\\x80-\\xff]+$/;\nvar TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;\nvar EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;\nvar DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\\x09\\x20]*(?:$|;)/;\nfunction contentDisposition(filename, options) {\n  var opts = options || ({});\n  var type = opts.type || 'attachment';\n  var params = createparams(filename, opts.fallback);\n  return format(new ContentDisposition(type, params));\n}\nfunction createparams(filename, fallback) {\n  if (filename === undefined) {\n    return;\n  }\n  var params = {};\n  if (typeof filename !== 'string') {\n    throw new TypeError('filename must be a string');\n  }\n  if (fallback === undefined) {\n    fallback = true;\n  }\n  if (typeof fallback !== 'string' && typeof fallback !== 'boolean') {\n    throw new TypeError('fallback must be a string or boolean');\n  }\n  if (typeof fallback === 'string' && NON_LATIN1_REGEXP.test(fallback)) {\n    throw new TypeError('fallback must be ISO-8859-1 string');\n  }\n  var name = basename(filename);\n  var isQuotedString = TEXT_REGEXP.test(name);\n  var fallbackName = typeof fallback !== 'string' ? fallback && getlatin1(name) : basename(fallback);\n  var hasFallback = typeof fallbackName === 'string' && fallbackName !== name;\n  if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {\n    params['filename*'] = name;\n  }\n  if (isQuotedString || hasFallback) {\n    params.filename = hasFallback ? fallbackName : name;\n  }\n  return params;\n}\nfunction format(obj) {\n  var parameters = obj.parameters;\n  var type = obj.type;\n  if (!type || typeof type !== 'string' || !TOKEN_REGEXP.test(type)) {\n    throw new TypeError('invalid type');\n  }\n  var string = String(type).toLowerCase();\n  if (parameters && typeof parameters === 'object') {\n    var param;\n    var params = Object.keys(parameters).sort();\n    for (var i = 0; i < params.length; i++) {\n      param = params[i];\n      var val = param.substr(-1) === '*' ? ustring(parameters[param]) : qstring(parameters[param]);\n      string += '; ' + param + '=' + val;\n    }\n  }\n  return string;\n}\nfunction decodefield(str) {\n  var match = EXT_VALUE_REGEXP.exec(str);\n  if (!match) {\n    throw new TypeError('invalid extended field value');\n  }\n  var charset = match[1].toLowerCase();\n  var encoded = match[2];\n  var value;\n  var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);\n  switch (charset) {\n    case 'iso-8859-1':\n      value = getlatin1(binary);\n      break;\n    case 'utf-8':\n      value = Buffer.from(binary, 'binary').toString('utf8');\n      break;\n    default:\n      throw new TypeError('unsupported charset in extended field');\n  }\n  return value;\n}\nfunction getlatin1(val) {\n  return String(val).replace(NON_LATIN1_REGEXP, '?');\n}\nfunction parse(string) {\n  if (!string || typeof string !== 'string') {\n    throw new TypeError('argument string is required');\n  }\n  var match = DISPOSITION_TYPE_REGEXP.exec(string);\n  if (!match) {\n    throw new TypeError('invalid type format');\n  }\n  var index = match[0].length;\n  var type = match[1].toLowerCase();\n  var key;\n  var names = [];\n  var params = {};\n  var value;\n  index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ';' ? index - 1 : index;\n  while (match = PARAM_REGEXP.exec(string)) {\n    if (match.index !== index) {\n      throw new TypeError('invalid parameter format');\n    }\n    index += match[0].length;\n    key = match[1].toLowerCase();\n    value = match[2];\n    if (names.indexOf(key) !== -1) {\n      throw new TypeError('invalid duplicate parameter');\n    }\n    names.push(key);\n    if (key.indexOf('*') + 1 === key.length) {\n      key = key.slice(0, -1);\n      value = decodefield(value);\n      params[key] = value;\n      continue;\n    }\n    if (typeof params[key] === 'string') {\n      continue;\n    }\n    if (value[0] === '\"') {\n      value = value.substr(1, value.length - 2).replace(QESC_REGEXP, '$1');\n    }\n    params[key] = value;\n  }\n  if (index !== -1 && index !== string.length) {\n    throw new TypeError('invalid parameter format');\n  }\n  return new ContentDisposition(type, params);\n}\nfunction pdecode(str, hex) {\n  return String.fromCharCode(parseInt(hex, 16));\n}\nfunction pencode(char) {\n  return '%' + String(char).charCodeAt(0).toString(16).toUpperCase();\n}\nfunction qstring(val) {\n  var str = String(val);\n  return '\"' + str.replace(QUOTE_REGEXP, '\\\\$1') + '\"';\n}\nfunction ustring(val) {\n  var str = String(val);\n  var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);\n  return 'UTF-8\\'\\'' + encoded;\n}\nfunction ContentDisposition(type, parameters) {\n  this.type = type;\n  this.parameters = parameters;\n}\n"}