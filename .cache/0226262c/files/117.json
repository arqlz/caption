{"contents":"\"use strict\";\nvar Buffer = __fusereq(98).Buffer;\nexports._dbcs = DBCSCodec;\nvar UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1000, UNASSIGNED_NODE = new Array(0x100), DEF_CHAR = -1;\nfor (var i = 0; i < 0x100; i++) UNASSIGNED_NODE[i] = UNASSIGNED;\nfunction DBCSCodec(codecOptions, iconv) {\n  this.encodingName = codecOptions.encodingName;\n  if (!codecOptions) throw new Error(\"DBCS codec is called without the data.\");\n  if (!codecOptions.table) throw new Error(\"Encoding '\" + this.encodingName + \"' has no data.\");\n  var mappingTable = codecOptions.table();\n  this.decodeTables = [];\n  this.decodeTables[0] = UNASSIGNED_NODE.slice(0);\n  this.decodeTableSeq = [];\n  for (var i = 0; i < mappingTable.length; i++) this._addDecodeChunk(mappingTable[i]);\n  this.defaultCharUnicode = iconv.defaultCharUnicode;\n  this.encodeTable = [];\n  this.encodeTableSeq = [];\n  var skipEncodeChars = {};\n  if (codecOptions.encodeSkipVals) for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {\n    var val = codecOptions.encodeSkipVals[i];\n    if (typeof val === 'number') skipEncodeChars[val] = true; else for (var j = val.from; j <= val.to; j++) skipEncodeChars[j] = true;\n  }\n  this._fillEncodeTable(0, 0, skipEncodeChars);\n  if (codecOptions.encodeAdd) {\n    for (var uChar in codecOptions.encodeAdd) if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);\n  }\n  this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];\n  if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];\n  if (this.defCharSB === UNASSIGNED) this.defCharSB = (\"?\").charCodeAt(0);\n  if (typeof codecOptions.gb18030 === 'function') {\n    this.gb18030 = codecOptions.gb18030();\n    var thirdByteNodeIdx = this.decodeTables.length;\n    var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);\n    var fourthByteNodeIdx = this.decodeTables.length;\n    var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);\n    for (var i = 0x81; i <= 0xFE; i++) {\n      var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];\n      var secondByteNode = this.decodeTables[secondByteNodeIdx];\n      for (var j = 0x30; j <= 0x39; j++) secondByteNode[j] = NODE_START - thirdByteNodeIdx;\n    }\n    for (var i = 0x81; i <= 0xFE; i++) thirdByteNode[i] = NODE_START - fourthByteNodeIdx;\n    for (var i = 0x30; i <= 0x39; i++) fourthByteNode[i] = GB18030_CODE;\n  }\n}\nDBCSCodec.prototype.encoder = DBCSEncoder;\nDBCSCodec.prototype.decoder = DBCSDecoder;\nDBCSCodec.prototype._getDecodeTrieNode = function (addr) {\n  var bytes = [];\n  for (; addr > 0; addr >>= 8) bytes.push(addr & 0xFF);\n  if (bytes.length == 0) bytes.push(0);\n  var node = this.decodeTables[0];\n  for (var i = bytes.length - 1; i > 0; i--) {\n    var val = node[bytes[i]];\n    if (val == UNASSIGNED) {\n      node[bytes[i]] = NODE_START - this.decodeTables.length;\n      this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));\n    } else if (val <= NODE_START) {\n      node = this.decodeTables[NODE_START - val];\n    } else throw new Error(\"Overwrite byte in \" + this.encodingName + \", addr: \" + addr.toString(16));\n  }\n  return node;\n};\nDBCSCodec.prototype._addDecodeChunk = function (chunk) {\n  var curAddr = parseInt(chunk[0], 16);\n  var writeTable = this._getDecodeTrieNode(curAddr);\n  curAddr = curAddr & 0xFF;\n  for (var k = 1; k < chunk.length; k++) {\n    var part = chunk[k];\n    if (typeof part === \"string\") {\n      for (var l = 0; l < part.length; ) {\n        var code = part.charCodeAt(l++);\n        if (0xD800 <= code && code < 0xDC00) {\n          var codeTrail = part.charCodeAt(l++);\n          if (0xDC00 <= codeTrail && codeTrail < 0xE000) writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00); else throw new Error(\"Incorrect surrogate pair in \" + this.encodingName + \" at chunk \" + chunk[0]);\n        } else if (0x0FF0 < code && code <= 0x0FFF) {\n          var len = 0xFFF - code + 2;\n          var seq = [];\n          for (var m = 0; m < len; m++) seq.push(part.charCodeAt(l++));\n          writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;\n          this.decodeTableSeq.push(seq);\n        } else writeTable[curAddr++] = code;\n      }\n    } else if (typeof part === \"number\") {\n      var charCode = writeTable[curAddr - 1] + 1;\n      for (var l = 0; l < part; l++) writeTable[curAddr++] = charCode++;\n    } else throw new Error(\"Incorrect type '\" + typeof part + \"' given in \" + this.encodingName + \" at chunk \" + chunk[0]);\n  }\n  if (curAddr > 0xFF) throw new Error(\"Incorrect chunk in \" + this.encodingName + \" at addr \" + chunk[0] + \": too long\" + curAddr);\n};\nDBCSCodec.prototype._getEncodeBucket = function (uCode) {\n  var high = uCode >> 8;\n  if (this.encodeTable[high] === undefined) this.encodeTable[high] = UNASSIGNED_NODE.slice(0);\n  return this.encodeTable[high];\n};\nDBCSCodec.prototype._setEncodeChar = function (uCode, dbcsCode) {\n  var bucket = this._getEncodeBucket(uCode);\n  var low = uCode & 0xFF;\n  if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode; else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;\n};\nDBCSCodec.prototype._setEncodeSequence = function (seq, dbcsCode) {\n  var uCode = seq[0];\n  var bucket = this._getEncodeBucket(uCode);\n  var low = uCode & 0xFF;\n  var node;\n  if (bucket[low] <= SEQ_START) {\n    node = this.encodeTableSeq[SEQ_START - bucket[low]];\n  } else {\n    node = {};\n    if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low];\n    bucket[low] = SEQ_START - this.encodeTableSeq.length;\n    this.encodeTableSeq.push(node);\n  }\n  for (var j = 1; j < seq.length - 1; j++) {\n    var oldVal = node[uCode];\n    if (typeof oldVal === 'object') node = oldVal; else {\n      node = node[uCode] = {};\n      if (oldVal !== undefined) node[DEF_CHAR] = oldVal;\n    }\n  }\n  uCode = seq[seq.length - 1];\n  node[uCode] = dbcsCode;\n};\nDBCSCodec.prototype._fillEncodeTable = function (nodeIdx, prefix, skipEncodeChars) {\n  var node = this.decodeTables[nodeIdx];\n  for (var i = 0; i < 0x100; i++) {\n    var uCode = node[i];\n    var mbCode = prefix + i;\n    if (skipEncodeChars[mbCode]) continue;\n    if (uCode >= 0) this._setEncodeChar(uCode, mbCode); else if (uCode <= NODE_START) this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars); else if (uCode <= SEQ_START) this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);\n  }\n};\nfunction DBCSEncoder(options, codec) {\n  this.leadSurrogate = -1;\n  this.seqObj = undefined;\n  this.encodeTable = codec.encodeTable;\n  this.encodeTableSeq = codec.encodeTableSeq;\n  this.defaultCharSingleByte = codec.defCharSB;\n  this.gb18030 = codec.gb18030;\n}\nDBCSEncoder.prototype.write = function (str) {\n  var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i = 0, j = 0;\n  while (true) {\n    if (nextChar === -1) {\n      if (i == str.length) break;\n      var uCode = str.charCodeAt(i++);\n    } else {\n      var uCode = nextChar;\n      nextChar = -1;\n    }\n    if (0xD800 <= uCode && uCode < 0xE000) {\n      if (uCode < 0xDC00) {\n        if (leadSurrogate === -1) {\n          leadSurrogate = uCode;\n          continue;\n        } else {\n          leadSurrogate = uCode;\n          uCode = UNASSIGNED;\n        }\n      } else {\n        if (leadSurrogate !== -1) {\n          uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);\n          leadSurrogate = -1;\n        } else {\n          uCode = UNASSIGNED;\n        }\n      }\n    } else if (leadSurrogate !== -1) {\n      nextChar = uCode;\n      uCode = UNASSIGNED;\n      leadSurrogate = -1;\n    }\n    var dbcsCode = UNASSIGNED;\n    if (seqObj !== undefined && uCode != UNASSIGNED) {\n      var resCode = seqObj[uCode];\n      if (typeof resCode === 'object') {\n        seqObj = resCode;\n        continue;\n      } else if (typeof resCode == 'number') {\n        dbcsCode = resCode;\n      } else if (resCode == undefined) {\n        resCode = seqObj[DEF_CHAR];\n        if (resCode !== undefined) {\n          dbcsCode = resCode;\n          nextChar = uCode;\n        } else {}\n      }\n      seqObj = undefined;\n    } else if (uCode >= 0) {\n      var subtable = this.encodeTable[uCode >> 8];\n      if (subtable !== undefined) dbcsCode = subtable[uCode & 0xFF];\n      if (dbcsCode <= SEQ_START) {\n        seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];\n        continue;\n      }\n      if (dbcsCode == UNASSIGNED && this.gb18030) {\n        var idx = findIdx(this.gb18030.uChars, uCode);\n        if (idx != -1) {\n          var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);\n          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600);\n          dbcsCode = dbcsCode % 12600;\n          newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260);\n          dbcsCode = dbcsCode % 1260;\n          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10);\n          dbcsCode = dbcsCode % 10;\n          newBuf[j++] = 0x30 + dbcsCode;\n          continue;\n        }\n      }\n    }\n    if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;\n    if (dbcsCode < 0x100) {\n      newBuf[j++] = dbcsCode;\n    } else if (dbcsCode < 0x10000) {\n      newBuf[j++] = dbcsCode >> 8;\n      newBuf[j++] = dbcsCode & 0xFF;\n    } else {\n      newBuf[j++] = dbcsCode >> 16;\n      newBuf[j++] = dbcsCode >> 8 & 0xFF;\n      newBuf[j++] = dbcsCode & 0xFF;\n    }\n  }\n  this.seqObj = seqObj;\n  this.leadSurrogate = leadSurrogate;\n  return newBuf.slice(0, j);\n};\nDBCSEncoder.prototype.end = function () {\n  if (this.leadSurrogate === -1 && this.seqObj === undefined) return;\n  var newBuf = Buffer.alloc(10), j = 0;\n  if (this.seqObj) {\n    var dbcsCode = this.seqObj[DEF_CHAR];\n    if (dbcsCode !== undefined) {\n      if (dbcsCode < 0x100) {\n        newBuf[j++] = dbcsCode;\n      } else {\n        newBuf[j++] = dbcsCode >> 8;\n        newBuf[j++] = dbcsCode & 0xFF;\n      }\n    } else {}\n    this.seqObj = undefined;\n  }\n  if (this.leadSurrogate !== -1) {\n    newBuf[j++] = this.defaultCharSingleByte;\n    this.leadSurrogate = -1;\n  }\n  return newBuf.slice(0, j);\n};\nDBCSEncoder.prototype.findIdx = findIdx;\nfunction DBCSDecoder(options, codec) {\n  this.nodeIdx = 0;\n  this.prevBuf = Buffer.alloc(0);\n  this.decodeTables = codec.decodeTables;\n  this.decodeTableSeq = codec.decodeTableSeq;\n  this.defaultCharUnicode = codec.defaultCharUnicode;\n  this.gb18030 = codec.gb18030;\n}\nDBCSDecoder.prototype.write = function (buf) {\n  var newBuf = Buffer.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length, seqStart = -this.prevBuf.length, uCode;\n  if (prevBufOffset > 0) prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);\n  for (var i = 0, j = 0; i < buf.length; i++) {\n    var curByte = i >= 0 ? buf[i] : prevBuf[i + prevBufOffset];\n    var uCode = this.decodeTables[nodeIdx][curByte];\n    if (uCode >= 0) {} else if (uCode === UNASSIGNED) {\n      i = seqStart;\n      uCode = this.defaultCharUnicode.charCodeAt(0);\n    } else if (uCode === GB18030_CODE) {\n      var curSeq = seqStart >= 0 ? buf.slice(seqStart, i + 1) : prevBuf.slice(seqStart + prevBufOffset, i + 1 + prevBufOffset);\n      var ptr = (curSeq[0] - 0x81) * 12600 + (curSeq[1] - 0x30) * 1260 + (curSeq[2] - 0x81) * 10 + (curSeq[3] - 0x30);\n      var idx = findIdx(this.gb18030.gbChars, ptr);\n      uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];\n    } else if (uCode <= NODE_START) {\n      nodeIdx = NODE_START - uCode;\n      continue;\n    } else if (uCode <= SEQ_START) {\n      var seq = this.decodeTableSeq[SEQ_START - uCode];\n      for (var k = 0; k < seq.length - 1; k++) {\n        uCode = seq[k];\n        newBuf[j++] = uCode & 0xFF;\n        newBuf[j++] = uCode >> 8;\n      }\n      uCode = seq[seq.length - 1];\n    } else throw new Error(\"iconv-lite internal error: invalid decoding table value \" + uCode + \" at \" + nodeIdx + \"/\" + curByte);\n    if (uCode > 0xFFFF) {\n      uCode -= 0x10000;\n      var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);\n      newBuf[j++] = uCodeLead & 0xFF;\n      newBuf[j++] = uCodeLead >> 8;\n      uCode = 0xDC00 + uCode % 0x400;\n    }\n    newBuf[j++] = uCode & 0xFF;\n    newBuf[j++] = uCode >> 8;\n    nodeIdx = 0;\n    seqStart = i + 1;\n  }\n  this.nodeIdx = nodeIdx;\n  this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);\n  return newBuf.slice(0, j).toString('ucs2');\n};\nDBCSDecoder.prototype.end = function () {\n  var ret = '';\n  while (this.prevBuf.length > 0) {\n    ret += this.defaultCharUnicode;\n    var buf = this.prevBuf.slice(1);\n    this.prevBuf = Buffer.alloc(0);\n    this.nodeIdx = 0;\n    if (buf.length > 0) ret += this.write(buf);\n  }\n  this.nodeIdx = 0;\n  return ret;\n};\nfunction findIdx(table, val) {\n  if (table[0] > val) return -1;\n  var l = 0, r = table.length;\n  while (l < r - 1) {\n    var mid = l + Math.floor((r - l + 1) / 2);\n    if (table[mid] <= val) l = mid; else r = mid;\n  }\n  return l;\n}\n"}