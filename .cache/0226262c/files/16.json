{"contents":"'use strict';\nvar bytes = __fusereq(52);\nvar contentType = __fusereq(53);\nvar createError = __fusereq(54);\nvar debug = __fusereq(23)('body-parser:json');\nvar read = __fusereq(55);\nvar typeis = __fusereq(34);\nmodule.exports = json;\nvar FIRST_CHAR_REGEXP = /^[\\x20\\x09\\x0a\\x0d]*(.)/;\nfunction json(options) {\n  var opts = options || ({});\n  var limit = typeof opts.limit !== 'number' ? bytes.parse(opts.limit || '100kb') : opts.limit;\n  var inflate = opts.inflate !== false;\n  var reviver = opts.reviver;\n  var strict = opts.strict !== false;\n  var type = opts.type || 'application/json';\n  var verify = opts.verify || false;\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function');\n  }\n  var shouldParse = typeof type !== 'function' ? typeChecker(type) : type;\n  function parse(body) {\n    if (body.length === 0) {\n      return {};\n    }\n    if (strict) {\n      var first = firstchar(body);\n      if (first !== '{' && first !== '[') {\n        debug('strict violation');\n        throw createStrictSyntaxError(body, first);\n      }\n    }\n    try {\n      debug('parse json');\n      return JSON.parse(body, reviver);\n    } catch (e) {\n      throw normalizeJsonSyntaxError(e, {\n        message: e.message,\n        stack: e.stack\n      });\n    }\n  }\n  return function jsonParser(req, res, next) {\n    if (req._body) {\n      debug('body already parsed');\n      next();\n      return;\n    }\n    req.body = req.body || ({});\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body');\n      next();\n      return;\n    }\n    debug('content-type %j', req.headers['content-type']);\n    if (!shouldParse(req)) {\n      debug('skip parsing');\n      next();\n      return;\n    }\n    var charset = getCharset(req) || 'utf-8';\n    if (charset.substr(0, 4) !== 'utf-') {\n      debug('invalid charset');\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\n        charset: charset,\n        type: 'charset.unsupported'\n      }));\n      return;\n    }\n    read(req, res, next, parse, debug, {\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    });\n  };\n}\nfunction createStrictSyntaxError(str, char) {\n  var index = str.indexOf(char);\n  var partial = str.substring(0, index) + '#';\n  try {\n    JSON.parse(partial);\n    throw new SyntaxError('strict violation');\n  } catch (e) {\n    return normalizeJsonSyntaxError(e, {\n      message: e.message.replace('#', char),\n      stack: e.stack\n    });\n  }\n}\nfunction firstchar(str) {\n  return FIRST_CHAR_REGEXP.exec(str)[1];\n}\nfunction getCharset(req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase();\n  } catch (e) {\n    return undefined;\n  }\n}\nfunction normalizeJsonSyntaxError(error, obj) {\n  var keys = Object.getOwnPropertyNames(error);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (key !== 'stack' && key !== 'message') {\n      delete error[key];\n    }\n  }\n  error.stack = obj.stack.replace(error.message, obj.message);\n  error.message = obj.message;\n  return error;\n}\nfunction typeChecker(type) {\n  return function checkType(req) {\n    return Boolean(typeis(req, type));\n  };\n}\n"}