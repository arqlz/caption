{"contents":"var process = __fusereq(59);\nvar buffer = __fusereq(51);\nvar Buffer = buffer;\n'use strict';\nvar bytes = __fusereq(52);\nvar createError = __fusereq(54);\nvar iconv = __fusereq(86);\nvar unpipe = __fusereq(58);\nmodule.exports = getRawBody;\nvar ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;\nfunction getDecoder(encoding) {\n  if (!encoding) return null;\n  try {\n    return iconv.getDecoder(encoding);\n  } catch (e) {\n    if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e;\n    throw createError(415, 'specified encoding unsupported', {\n      encoding: encoding,\n      type: 'encoding.unsupported'\n    });\n  }\n}\nfunction getRawBody(stream, options, callback) {\n  var done = callback;\n  var opts = options || ({});\n  if (options === true || typeof options === 'string') {\n    opts = {\n      encoding: options\n    };\n  }\n  if (typeof options === 'function') {\n    done = options;\n    opts = {};\n  }\n  if (done !== undefined && typeof done !== 'function') {\n    throw new TypeError('argument callback must be a function');\n  }\n  if (!done && !window.Promise) {\n    throw new TypeError('argument callback is required');\n  }\n  var encoding = opts.encoding !== true ? opts.encoding : 'utf-8';\n  var limit = bytes.parse(opts.limit);\n  var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;\n  if (done) {\n    return readStream(stream, encoding, length, limit, done);\n  }\n  return new Promise(function executor(resolve, reject) {\n    readStream(stream, encoding, length, limit, function onRead(err, buf) {\n      if (err) return reject(err);\n      resolve(buf);\n    });\n  });\n}\nfunction halt(stream) {\n  unpipe(stream);\n  if (typeof stream.pause === 'function') {\n    stream.pause();\n  }\n}\nfunction readStream(stream, encoding, length, limit, callback) {\n  var complete = false;\n  var sync = true;\n  if (limit !== null && length !== null && length > limit) {\n    return done(createError(413, 'request entity too large', {\n      expected: length,\n      length: length,\n      limit: limit,\n      type: 'entity.too.large'\n    }));\n  }\n  var state = stream._readableState;\n  if (stream._decoder || state && (state.encoding || state.decoder)) {\n    return done(createError(500, 'stream encoding should not be set', {\n      type: 'stream.encoding.set'\n    }));\n  }\n  var received = 0;\n  var decoder;\n  try {\n    decoder = getDecoder(encoding);\n  } catch (err) {\n    return done(err);\n  }\n  var buffer = decoder ? '' : [];\n  stream.on('aborted', onAborted);\n  stream.on('close', cleanup);\n  stream.on('data', onData);\n  stream.on('end', onEnd);\n  stream.on('error', onEnd);\n  sync = false;\n  function done() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    complete = true;\n    if (sync) {\n      process.nextTick(invokeCallback);\n    } else {\n      invokeCallback();\n    }\n    function invokeCallback() {\n      cleanup();\n      if (args[0]) {\n        halt(stream);\n      }\n      callback.apply(null, args);\n    }\n  }\n  function onAborted() {\n    if (complete) return;\n    done(createError(400, 'request aborted', {\n      code: 'ECONNABORTED',\n      expected: length,\n      length: length,\n      received: received,\n      type: 'request.aborted'\n    }));\n  }\n  function onData(chunk) {\n    if (complete) return;\n    received += chunk.length;\n    if (limit !== null && received > limit) {\n      done(createError(413, 'request entity too large', {\n        limit: limit,\n        received: received,\n        type: 'entity.too.large'\n      }));\n    } else if (decoder) {\n      buffer += decoder.write(chunk);\n    } else {\n      buffer.push(chunk);\n    }\n  }\n  function onEnd(err) {\n    if (complete) return;\n    if (err) return done(err);\n    if (length !== null && received !== length) {\n      done(createError(400, 'request size did not match content length', {\n        expected: length,\n        length: length,\n        received: received,\n        type: 'request.size.invalid'\n      }));\n    } else {\n      var string = decoder ? buffer + (decoder.end() || '') : Buffer.concat(buffer);\n      done(null, string);\n    }\n  }\n  function cleanup() {\n    buffer = null;\n    stream.removeListener('aborted', onAborted);\n    stream.removeListener('data', onData);\n    stream.removeListener('end', onEnd);\n    stream.removeListener('error', onEnd);\n    stream.removeListener('close', cleanup);\n  }\n}\n"}