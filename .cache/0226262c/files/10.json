{"contents":"'use strict';\nvar Route = __fusereq(9);\nvar Layer = __fusereq(31);\nvar methods = __fusereq(21);\nvar mixin = __fusereq(28);\nvar debug = __fusereq(23)('express:router');\nvar deprecate = __fusereq(15)('express');\nvar flatten = __fusereq(27);\nvar parseUrl = __fusereq(37);\nvar setPrototypeOf = __fusereq(30);\nvar objectRegExp = /^\\[object (\\S+)\\]$/;\nvar slice = Array.prototype.slice;\nvar toString = Object.prototype.toString;\nvar proto = module.exports = function (options) {\n  var opts = options || ({});\n  function router(req, res, next) {\n    router.handle(req, res, next);\n  }\n  setPrototypeOf(router, proto);\n  router.params = {};\n  router._params = [];\n  router.caseSensitive = opts.caseSensitive;\n  router.mergeParams = opts.mergeParams;\n  router.strict = opts.strict;\n  router.stack = [];\n  return router;\n};\nproto.param = function param(name, fn) {\n  if (typeof name === 'function') {\n    deprecate('router.param(fn): Refactor to use path params');\n    this._params.push(name);\n    return;\n  }\n  var params = this._params;\n  var len = params.length;\n  var ret;\n  if (name[0] === ':') {\n    deprecate('router.param(' + JSON.stringify(name) + ', fn): Use router.param(' + JSON.stringify(name.substr(1)) + ', fn) instead');\n    name = name.substr(1);\n  }\n  for (var i = 0; i < len; ++i) {\n    if (ret = params[i](name, fn)) {\n      fn = ret;\n    }\n  }\n  if ('function' !== typeof fn) {\n    throw new Error('invalid param() call for ' + name + ', got ' + fn);\n  }\n  (this.params[name] = this.params[name] || []).push(fn);\n  return this;\n};\nproto.handle = function handle(req, res, out) {\n  var self = this;\n  debug('dispatching %s %s', req.method, req.url);\n  var idx = 0;\n  var protohost = getProtohost(req.url) || '';\n  var removed = '';\n  var slashAdded = false;\n  var paramcalled = {};\n  var options = [];\n  var stack = self.stack;\n  var parentParams = req.params;\n  var parentUrl = req.baseUrl || '';\n  var done = restore(out, req, 'baseUrl', 'next', 'params');\n  req.next = next;\n  if (req.method === 'OPTIONS') {\n    done = wrap(done, function (old, err) {\n      if (err || options.length === 0) return old(err);\n      sendOptionsResponse(res, options, old);\n    });\n  }\n  req.baseUrl = parentUrl;\n  req.originalUrl = req.originalUrl || req.url;\n  next();\n  function next(err) {\n    var layerError = err === 'route' ? null : err;\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n    if (layerError === 'router') {\n      setImmediate(done, null);\n      return;\n    }\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n    var path = getPathname(req);\n    if (path == null) {\n      return done(layerError);\n    }\n    var layer;\n    var match;\n    var route;\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n      if (typeof match !== 'boolean') {\n        layerError = layerError || match;\n      }\n      if (match !== true) {\n        continue;\n      }\n      if (!route) {\n        continue;\n      }\n      if (layerError) {\n        match = false;\n        continue;\n      }\n      var method = req.method;\n      var has_method = route._handles_method(method);\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n    if (match !== true) {\n      return done(layerError);\n    }\n    if (route) {\n      req.route = route;\n    }\n    req.params = self.mergeParams ? mergeParams(layer.params, parentParams) : layer.params;\n    var layerPath = layer.path;\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  }\n  function trim_prefix(layer, layerError, layerPath, path) {\n    if (layerPath.length !== 0) {\n      if (layerPath !== path.substr(0, layerPath.length)) {\n        next(layerError);\n        return;\n      }\n      var c = path[layerPath.length];\n      if (c && c !== '/' && c !== '.') return next(layerError);\n      debug('trim prefix (%s) from url %s', layerPath, req.url);\n      removed = layerPath;\n      req.url = protohost + req.url.substr(protohost.length + removed.length);\n      if (!protohost && req.url[0] !== '/') {\n        req.url = '/' + req.url;\n        slashAdded = true;\n      }\n      req.baseUrl = parentUrl + (removed[removed.length - 1] === '/' ? removed.substring(0, removed.length - 1) : removed);\n    }\n    debug('%s %s : %s', layer.name, layerPath, req.originalUrl);\n    if (layerError) {\n      layer.handle_error(layerError, req, res, next);\n    } else {\n      layer.handle_request(req, res, next);\n    }\n  }\n};\nproto.process_params = function process_params(layer, called, req, res, done) {\n  var params = this.params;\n  var keys = layer.keys;\n  if (!keys || keys.length === 0) {\n    return done();\n  }\n  var i = 0;\n  var name;\n  var paramIndex = 0;\n  var key;\n  var paramVal;\n  var paramCallbacks;\n  var paramCalled;\n  function param(err) {\n    if (err) {\n      return done(err);\n    }\n    if (i >= keys.length) {\n      return done();\n    }\n    paramIndex = 0;\n    key = keys[i++];\n    name = key.name;\n    paramVal = req.params[name];\n    paramCallbacks = params[name];\n    paramCalled = called[name];\n    if (paramVal === undefined || !paramCallbacks) {\n      return param();\n    }\n    if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== 'route')) {\n      req.params[name] = paramCalled.value;\n      return param(paramCalled.error);\n    }\n    called[name] = paramCalled = {\n      error: null,\n      match: paramVal,\n      value: paramVal\n    };\n    paramCallback();\n  }\n  function paramCallback(err) {\n    var fn = paramCallbacks[paramIndex++];\n    paramCalled.value = req.params[key.name];\n    if (err) {\n      paramCalled.error = err;\n      param(err);\n      return;\n    }\n    if (!fn) return param();\n    try {\n      fn(req, res, paramCallback, paramVal, key.name);\n    } catch (e) {\n      paramCallback(e);\n    }\n  }\n  param();\n};\nproto.use = function use(fn) {\n  var offset = 0;\n  var path = '/';\n  if (typeof fn !== 'function') {\n    var arg = fn;\n    while (Array.isArray(arg) && arg.length !== 0) {\n      arg = arg[0];\n    }\n    if (typeof arg !== 'function') {\n      offset = 1;\n      path = fn;\n    }\n  }\n  var callbacks = flatten(slice.call(arguments, offset));\n  if (callbacks.length === 0) {\n    throw new TypeError('Router.use() requires a middleware function');\n  }\n  for (var i = 0; i < callbacks.length; i++) {\n    var fn = callbacks[i];\n    if (typeof fn !== 'function') {\n      throw new TypeError('Router.use() requires a middleware function but got a ' + gettype(fn));\n    }\n    debug('use %o %s', path, fn.name || '<anonymous>');\n    var layer = new Layer(path, {\n      sensitive: this.caseSensitive,\n      strict: false,\n      end: false\n    }, fn);\n    layer.route = undefined;\n    this.stack.push(layer);\n  }\n  return this;\n};\nproto.route = function route(path) {\n  var route = new Route(path);\n  var layer = new Layer(path, {\n    sensitive: this.caseSensitive,\n    strict: this.strict,\n    end: true\n  }, route.dispatch.bind(route));\n  layer.route = route;\n  this.stack.push(layer);\n  return route;\n};\nmethods.concat('all').forEach(function (method) {\n  proto[method] = function (path) {\n    var route = this.route(path);\n    route[method].apply(route, slice.call(arguments, 1));\n    return this;\n  };\n});\nfunction appendMethods(list, addition) {\n  for (var i = 0; i < addition.length; i++) {\n    var method = addition[i];\n    if (list.indexOf(method) === -1) {\n      list.push(method);\n    }\n  }\n}\nfunction getPathname(req) {\n  try {\n    return parseUrl(req).pathname;\n  } catch (err) {\n    return undefined;\n  }\n}\nfunction getProtohost(url) {\n  if (typeof url !== 'string' || url.length === 0 || url[0] === '/') {\n    return undefined;\n  }\n  var searchIndex = url.indexOf('?');\n  var pathLength = searchIndex !== -1 ? searchIndex : url.length;\n  var fqdnIndex = url.substr(0, pathLength).indexOf('://');\n  return fqdnIndex !== -1 ? url.substr(0, url.indexOf('/', 3 + fqdnIndex)) : undefined;\n}\nfunction gettype(obj) {\n  var type = typeof obj;\n  if (type !== 'object') {\n    return type;\n  }\n  return toString.call(obj).replace(objectRegExp, '$1');\n}\nfunction matchLayer(layer, path) {\n  try {\n    return layer.match(path);\n  } catch (err) {\n    return err;\n  }\n}\nfunction mergeParams(params, parent) {\n  if (typeof parent !== 'object' || !parent) {\n    return params;\n  }\n  var obj = mixin({}, parent);\n  if (!((0 in params)) || !((0 in parent))) {\n    return mixin(obj, params);\n  }\n  var i = 0;\n  var o = 0;\n  while ((i in params)) {\n    i++;\n  }\n  while ((o in parent)) {\n    o++;\n  }\n  for (i--; i >= 0; i--) {\n    params[i + o] = params[i];\n    if (i < o) {\n      delete params[i];\n    }\n  }\n  return mixin(obj, params);\n}\nfunction restore(fn, obj) {\n  var props = new Array(arguments.length - 2);\n  var vals = new Array(arguments.length - 2);\n  for (var i = 0; i < props.length; i++) {\n    props[i] = arguments[i + 2];\n    vals[i] = obj[props[i]];\n  }\n  return function () {\n    for (var i = 0; i < props.length; i++) {\n      obj[props[i]] = vals[i];\n    }\n    return fn.apply(this, arguments);\n  };\n}\nfunction sendOptionsResponse(res, options, next) {\n  try {\n    var body = options.join(',');\n    res.set('Allow', body);\n    res.send(body);\n  } catch (err) {\n    next(err);\n  }\n}\nfunction wrap(old, fn) {\n  return function proxy() {\n    var args = new Array(arguments.length + 1);\n    args[0] = old;\n    for (var i = 0, len = arguments.length; i < len; i++) {\n      args[i + 1] = arguments[i];\n    }\n    fn.apply(this, args);\n  };\n}\n"}