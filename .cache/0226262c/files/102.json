{"contents":"\"use strict\";\nvar Buffer = __fusereq(51).Buffer;\nmodule.exports = function (iconv) {\n  var original = undefined;\n  iconv.supportsNodeEncodingsExtension = !(Buffer.from || new Buffer(0) instanceof Uint8Array);\n  iconv.extendNodeEncodings = function extendNodeEncodings() {\n    if (original) return;\n    original = {};\n    if (!iconv.supportsNodeEncodingsExtension) {\n      console.error(\"ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node\");\n      console.error(\"See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility\");\n      return;\n    }\n    var nodeNativeEncodings = {\n      'hex': true,\n      'utf8': true,\n      'utf-8': true,\n      'ascii': true,\n      'binary': true,\n      'base64': true,\n      'ucs2': true,\n      'ucs-2': true,\n      'utf16le': true,\n      'utf-16le': true\n    };\n    Buffer.isNativeEncoding = function (enc) {\n      return enc && nodeNativeEncodings[enc.toLowerCase()];\n    };\n    var SlowBuffer = __fusereq(51).SlowBuffer;\n    original.SlowBufferToString = SlowBuffer.prototype.toString;\n    SlowBuffer.prototype.toString = function (encoding, start, end) {\n      encoding = String(encoding || 'utf8').toLowerCase();\n      if (Buffer.isNativeEncoding(encoding)) return original.SlowBufferToString.call(this, encoding, start, end);\n      if (typeof start == 'undefined') start = 0;\n      if (typeof end == 'undefined') end = this.length;\n      return iconv.decode(this.slice(start, end), encoding);\n    };\n    original.SlowBufferWrite = SlowBuffer.prototype.write;\n    SlowBuffer.prototype.write = function (string, offset, length, encoding) {\n      if (isFinite(offset)) {\n        if (!isFinite(length)) {\n          encoding = length;\n          length = undefined;\n        }\n      } else {\n        var swap = encoding;\n        encoding = offset;\n        offset = length;\n        length = swap;\n      }\n      offset = +offset || 0;\n      var remaining = this.length - offset;\n      if (!length) {\n        length = remaining;\n      } else {\n        length = +length;\n        if (length > remaining) {\n          length = remaining;\n        }\n      }\n      encoding = String(encoding || 'utf8').toLowerCase();\n      if (Buffer.isNativeEncoding(encoding)) return original.SlowBufferWrite.call(this, string, offset, length, encoding);\n      if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError('attempt to write beyond buffer bounds');\n      var buf = iconv.encode(string, encoding);\n      if (buf.length < length) length = buf.length;\n      buf.copy(this, offset, 0, length);\n      return length;\n    };\n    original.BufferIsEncoding = Buffer.isEncoding;\n    Buffer.isEncoding = function (encoding) {\n      return Buffer.isNativeEncoding(encoding) || iconv.encodingExists(encoding);\n    };\n    original.BufferByteLength = Buffer.byteLength;\n    Buffer.byteLength = SlowBuffer.byteLength = function (str, encoding) {\n      encoding = String(encoding || 'utf8').toLowerCase();\n      if (Buffer.isNativeEncoding(encoding)) return original.BufferByteLength.call(this, str, encoding);\n      return iconv.encode(str, encoding).length;\n    };\n    original.BufferToString = Buffer.prototype.toString;\n    Buffer.prototype.toString = function (encoding, start, end) {\n      encoding = String(encoding || 'utf8').toLowerCase();\n      if (Buffer.isNativeEncoding(encoding)) return original.BufferToString.call(this, encoding, start, end);\n      if (typeof start == 'undefined') start = 0;\n      if (typeof end == 'undefined') end = this.length;\n      return iconv.decode(this.slice(start, end), encoding);\n    };\n    original.BufferWrite = Buffer.prototype.write;\n    Buffer.prototype.write = function (string, offset, length, encoding) {\n      var _offset = offset, _length = length, _encoding = encoding;\n      if (isFinite(offset)) {\n        if (!isFinite(length)) {\n          encoding = length;\n          length = undefined;\n        }\n      } else {\n        var swap = encoding;\n        encoding = offset;\n        offset = length;\n        length = swap;\n      }\n      encoding = String(encoding || 'utf8').toLowerCase();\n      if (Buffer.isNativeEncoding(encoding)) return original.BufferWrite.call(this, string, _offset, _length, _encoding);\n      offset = +offset || 0;\n      var remaining = this.length - offset;\n      if (!length) {\n        length = remaining;\n      } else {\n        length = +length;\n        if (length > remaining) {\n          length = remaining;\n        }\n      }\n      if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError('attempt to write beyond buffer bounds');\n      var buf = iconv.encode(string, encoding);\n      if (buf.length < length) length = buf.length;\n      buf.copy(this, offset, 0, length);\n      return length;\n    };\n    if (iconv.supportsStreams) {\n      var Readable = __fusereq(78).Readable;\n      original.ReadableSetEncoding = Readable.prototype.setEncoding;\n      Readable.prototype.setEncoding = function setEncoding(enc, options) {\n        this._readableState.decoder = iconv.getDecoder(enc, options);\n        this._readableState.encoding = enc;\n      };\n      Readable.prototype.collect = iconv._collect;\n    }\n  };\n  iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {\n    if (!iconv.supportsNodeEncodingsExtension) return;\n    if (!original) throw new Error(\"require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.\");\n    delete Buffer.isNativeEncoding;\n    var SlowBuffer = __fusereq(51).SlowBuffer;\n    SlowBuffer.prototype.toString = original.SlowBufferToString;\n    SlowBuffer.prototype.write = original.SlowBufferWrite;\n    Buffer.isEncoding = original.BufferIsEncoding;\n    Buffer.byteLength = original.BufferByteLength;\n    Buffer.prototype.toString = original.BufferToString;\n    Buffer.prototype.write = original.BufferWrite;\n    if (iconv.supportsStreams) {\n      var Readable = __fusereq(78).Readable;\n      Readable.prototype.setEncoding = original.ReadableSetEncoding;\n      delete Readable.prototype.collect;\n    }\n    original = undefined;\n  };\n};\n"}