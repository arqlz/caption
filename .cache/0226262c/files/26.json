{"contents":"'use strict';\nvar Buffer = __fusereq(39).Buffer;\nvar contentDisposition = __fusereq(40);\nvar contentType = __fusereq(53);\nvar deprecate = __fusereq(15)('express');\nvar flatten = __fusereq(27);\nvar mime = __fusereq(47).mime;\nvar etag = __fusereq(61);\nvar proxyaddr = __fusereq(38);\nvar qs = __fusereq(49);\nvar querystring = __fusereq(56);\nexports.etag = createETagGenerator({\n  weak: false\n});\nexports.wetag = createETagGenerator({\n  weak: true\n});\nexports.isAbsolute = function (path) {\n  if ('/' === path[0]) return true;\n  if (':' === path[1] && ('\\\\' === path[2] || '/' === path[2])) return true;\n  if ('\\\\\\\\' === path.substring(0, 2)) return true;\n};\nexports.flatten = deprecate.function(flatten, 'utils.flatten: use array-flatten npm module instead');\nexports.normalizeType = function (type) {\n  return ~type.indexOf('/') ? acceptParams(type) : {\n    value: mime.lookup(type),\n    params: {}\n  };\n};\nexports.normalizeTypes = function (types) {\n  var ret = [];\n  for (var i = 0; i < types.length; ++i) {\n    ret.push(exports.normalizeType(types[i]));\n  }\n  return ret;\n};\nexports.contentDisposition = deprecate.function(contentDisposition, 'utils.contentDisposition: use content-disposition npm module instead');\nfunction acceptParams(str, index) {\n  var parts = str.split(/ *; */);\n  var ret = {\n    value: parts[0],\n    quality: 1,\n    params: {},\n    originalIndex: index\n  };\n  for (var i = 1; i < parts.length; ++i) {\n    var pms = parts[i].split(/ *= */);\n    if ('q' === pms[0]) {\n      ret.quality = parseFloat(pms[1]);\n    } else {\n      ret.params[pms[0]] = pms[1];\n    }\n  }\n  return ret;\n}\nexports.compileETag = function (val) {\n  var fn;\n  if (typeof val === 'function') {\n    return val;\n  }\n  switch (val) {\n    case true:\n    case 'weak':\n      fn = exports.wetag;\n      break;\n    case false:\n      break;\n    case 'strong':\n      fn = exports.etag;\n      break;\n    default:\n      throw new TypeError('unknown value for etag function: ' + val);\n  }\n  return fn;\n};\nexports.compileQueryParser = function compileQueryParser(val) {\n  var fn;\n  if (typeof val === 'function') {\n    return val;\n  }\n  switch (val) {\n    case true:\n    case 'simple':\n      fn = querystring.parse;\n      break;\n    case false:\n      fn = newObject;\n      break;\n    case 'extended':\n      fn = parseExtendedQueryString;\n      break;\n    default:\n      throw new TypeError('unknown value for query parser function: ' + val);\n  }\n  return fn;\n};\nexports.compileTrust = function (val) {\n  if (typeof val === 'function') return val;\n  if (val === true) {\n    return function () {\n      return true;\n    };\n  }\n  if (typeof val === 'number') {\n    return function (a, i) {\n      return i < val;\n    };\n  }\n  if (typeof val === 'string') {\n    val = val.split(',').map(function (v) {\n      return v.trim();\n    });\n  }\n  return proxyaddr.compile(val || []);\n};\nexports.setCharset = function setCharset(type, charset) {\n  if (!type || !charset) {\n    return type;\n  }\n  var parsed = contentType.parse(type);\n  parsed.parameters.charset = charset;\n  return contentType.format(parsed);\n};\nfunction createETagGenerator(options) {\n  return function generateETag(body, encoding) {\n    var buf = !Buffer.isBuffer(body) ? Buffer.from(body, encoding) : body;\n    return etag(buf, options);\n  };\n}\nfunction parseExtendedQueryString(str) {\n  return qs.parse(str, {\n    allowPrototypes: true\n  });\n}\nfunction newObject() {\n  return {};\n}\n"}