{"contents":"'use strict';\nvar bytes = __fusereq(52);\nvar contentType = __fusereq(53);\nvar debug = __fusereq(23)('body-parser:text');\nvar read = __fusereq(55);\nvar typeis = __fusereq(34);\nmodule.exports = text;\nfunction text(options) {\n  var opts = options || ({});\n  var defaultCharset = opts.defaultCharset || 'utf-8';\n  var inflate = opts.inflate !== false;\n  var limit = typeof opts.limit !== 'number' ? bytes.parse(opts.limit || '100kb') : opts.limit;\n  var type = opts.type || 'text/plain';\n  var verify = opts.verify || false;\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function');\n  }\n  var shouldParse = typeof type !== 'function' ? typeChecker(type) : type;\n  function parse(buf) {\n    return buf;\n  }\n  return function textParser(req, res, next) {\n    if (req._body) {\n      debug('body already parsed');\n      next();\n      return;\n    }\n    req.body = req.body || ({});\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body');\n      next();\n      return;\n    }\n    debug('content-type %j', req.headers['content-type']);\n    if (!shouldParse(req)) {\n      debug('skip parsing');\n      next();\n      return;\n    }\n    var charset = getCharset(req) || defaultCharset;\n    read(req, res, next, parse, debug, {\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    });\n  };\n}\nfunction getCharset(req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase();\n  } catch (e) {\n    return undefined;\n  }\n}\nfunction typeChecker(type) {\n  return function checkType(req) {\n    return Boolean(typeis(req, type));\n  };\n}\n"}