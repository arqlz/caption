{"contents":"'use strict';\nmodule.exports = proxyaddr;\nmodule.exports.all = alladdrs;\nmodule.exports.compile = compile;\nvar forwarded = __fusereq(66);\nvar ipaddr = __fusereq(67);\nvar DIGIT_REGEXP = /^[0-9]+$/;\nvar isip = ipaddr.isValid;\nvar parseip = ipaddr.parse;\nvar IP_RANGES = {\n  linklocal: ['169.254.0.0/16', 'fe80::/10'],\n  loopback: ['127.0.0.1/8', '::1/128'],\n  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']\n};\nfunction alladdrs(req, trust) {\n  var addrs = forwarded(req);\n  if (!trust) {\n    return addrs;\n  }\n  if (typeof trust !== 'function') {\n    trust = compile(trust);\n  }\n  for (var i = 0; i < addrs.length - 1; i++) {\n    if (trust(addrs[i], i)) continue;\n    addrs.length = i + 1;\n  }\n  return addrs;\n}\nfunction compile(val) {\n  if (!val) {\n    throw new TypeError('argument is required');\n  }\n  var trust;\n  if (typeof val === 'string') {\n    trust = [val];\n  } else if (Array.isArray(val)) {\n    trust = val.slice();\n  } else {\n    throw new TypeError('unsupported trust argument');\n  }\n  for (var i = 0; i < trust.length; i++) {\n    val = trust[i];\n    if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {\n      continue;\n    }\n    val = IP_RANGES[val];\n    trust.splice.apply(trust, [i, 1].concat(val));\n    i += val.length - 1;\n  }\n  return compileTrust(compileRangeSubnets(trust));\n}\nfunction compileRangeSubnets(arr) {\n  var rangeSubnets = new Array(arr.length);\n  for (var i = 0; i < arr.length; i++) {\n    rangeSubnets[i] = parseipNotation(arr[i]);\n  }\n  return rangeSubnets;\n}\nfunction compileTrust(rangeSubnets) {\n  var len = rangeSubnets.length;\n  return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);\n}\nfunction parseipNotation(note) {\n  var pos = note.lastIndexOf('/');\n  var str = pos !== -1 ? note.substring(0, pos) : note;\n  if (!isip(str)) {\n    throw new TypeError('invalid IP address: ' + str);\n  }\n  var ip = parseip(str);\n  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {\n    ip = ip.toIPv4Address();\n  }\n  var max = ip.kind() === 'ipv6' ? 128 : 32;\n  var range = pos !== -1 ? note.substring(pos + 1, note.length) : null;\n  if (range === null) {\n    range = max;\n  } else if (DIGIT_REGEXP.test(range)) {\n    range = parseInt(range, 10);\n  } else if (ip.kind() === 'ipv4' && isip(range)) {\n    range = parseNetmask(range);\n  } else {\n    range = null;\n  }\n  if (range <= 0 || range > max) {\n    throw new TypeError('invalid range on address: ' + note);\n  }\n  return [ip, range];\n}\nfunction parseNetmask(netmask) {\n  var ip = parseip(netmask);\n  var kind = ip.kind();\n  return kind === 'ipv4' ? ip.prefixLengthFromSubnetMask() : null;\n}\nfunction proxyaddr(req, trust) {\n  if (!req) {\n    throw new TypeError('req argument is required');\n  }\n  if (!trust) {\n    throw new TypeError('trust argument is required');\n  }\n  var addrs = alladdrs(req, trust);\n  var addr = addrs[addrs.length - 1];\n  return addr;\n}\nfunction trustNone() {\n  return false;\n}\nfunction trustMulti(subnets) {\n  return function trust(addr) {\n    if (!isip(addr)) return false;\n    var ip = parseip(addr);\n    var ipconv;\n    var kind = ip.kind();\n    for (var i = 0; i < subnets.length; i++) {\n      var subnet = subnets[i];\n      var subnetip = subnet[0];\n      var subnetkind = subnetip.kind();\n      var subnetrange = subnet[1];\n      var trusted = ip;\n      if (kind !== subnetkind) {\n        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {\n          continue;\n        }\n        if (!ipconv) {\n          ipconv = subnetkind === 'ipv4' ? ip.toIPv4Address() : ip.toIPv4MappedAddress();\n        }\n        trusted = ipconv;\n      }\n      if (trusted.match(subnetip, subnetrange)) {\n        return true;\n      }\n    }\n    return false;\n  };\n}\nfunction trustSingle(subnet) {\n  var subnetip = subnet[0];\n  var subnetkind = subnetip.kind();\n  var subnetisipv4 = subnetkind === 'ipv4';\n  var subnetrange = subnet[1];\n  return function trust(addr) {\n    if (!isip(addr)) return false;\n    var ip = parseip(addr);\n    var kind = ip.kind();\n    if (kind !== subnetkind) {\n      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {\n        return false;\n      }\n      ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();\n    }\n    return ip.match(subnetip, subnetrange);\n  };\n}\n"}